在学习数据结构与算法的时候，我们会首先学习两个度，一个时间复杂度，一个空间复杂度。

算法效率的度量方法分为事后统计法和事前分析估算法
- 事后统计法的缺点很明显：

    ①:必须依据事先编写好的程序;
    
    ②:时间的比较依赖硬件和软件等环境因素; 

    ③:算法的测试数据设计困难;

- 事前分析估算法:其核心是把程序看成是独立于程序设计语言的算法或者一系列步骤

# 时间复杂度
定义:在进行算法分析的时候，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)
随n的变化情况并确定T(n)的数量级。算法时间复杂度记做:T(n)=O(f(n))。
表示 随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称为算法的渐进时间复杂度，简称时间复杂度。
其中f(n)是问题规模n的某个函数。

大O()就用来体现算法时间复杂度。

## 推导大O阶法
1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，那么去除与这个项相乘的常数。

## 举例
### 常数阶
```java
int sum = 0;                /*执行一次*/
int n = 0;                  /*执行一次*/
sum = (1 + n) * n /2;       /*执行一次*/
System.out.println(sum);    /*执行一次*/
```
此时算法的执行次数函数为f(n)=4，根据推导的大O阶法，此时的时间复杂度为O(1);
注意：只要是执行了常数次的，其时间复杂度就是O(1)而不区分O(2)，O(3)....

### 线性阶
```java
int i;                      /*执行一次*/
for(int i = 0; i < n; i++){ /*执行n次*/
    System.out.println(i);  /*执行一次*/
}
```
总的时间复杂度就是1 + n + 1 = n + 2次
其时间复杂度O(n)

### 对数阶
```java
int count = 1;
while(count < n){
    count = count * 2;
}
```
在执行语句`count = count * 2`的时候，这样count很再每次乘之后距离n更近，
那么需要执行多少次才能到n呢？ 
$$
2^{x}=n
$$
那么
$$
x = log_2{n}
$$
所以时间复杂度为：`O(logn)`



### 平方阶

```java
int i, j;
for(int i = 0; i < n; i++){
    for(int j = 0; j < n; j++){
        System.out.println(i + ", " + j);
    }
}
```

外层循环经过n次，内层循环也经过n次，那么时间复杂度为：
$$
O(n^{2})
$$
如果此时情况为：

```java
int i, j;
for(int i = 0; i < n; i++){
    for(int j = i; j < n; j++){
        System.out.println(i * j);
    }
}
```

当i = 0的时候，内循环执行了n次; i = 1的时候，内循环执行了n - 1次; i = n - 1的时候，内循环执行了1次，那么总共执行了
$$
n + (n - 1) + ... + 1 = \frac{n ^{2}}{2}+ \frac{n}{2}\qquad 
$$
此时的时间复杂度为：
$$
O(n^{2})
$$


## 时间复杂度从小到大排序

$$
O(1) < O(logn) < O(n) < O(nlogn) < O(n^{2}) < O(n^{3}) < O(2 ^{n}) < O(n!) < O(n^{n})
$$



# 空间复杂度

算法的空间复杂度通过计算算法所需的存储空间实现的，算法空间复杂度的计算公式为：
$$
S(n) = O(f(n))
$$
其中n为问题的规模，f(n)为语句关于n所占存储空间的函数
